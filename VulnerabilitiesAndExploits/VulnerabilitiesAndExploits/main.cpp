#include <iostream>
#include <iostream>
#include <string.h>
#include <string>

using namespace std;

//Selene
void arrayWorking();
void arrayExploit();
//arcWorking();
//arcExploit();

//Leandro
// To VTable Spraying
void vTableExploit();
void vTableWorking();
//  To Stack Smashing
void stackWorking();
void stackExploit();
void stackVulnerability();

//Landon
//heapWorking();
//heapExploit();

//Jaren
void intWorking();
void intExploit();
void ansiWorking();
void ansiExploit();

/*************************************
 * ARRAY VULNERABILTY
 * 1. There must be an array and an array index variable
 * 2. The array index variable must be reachable through external input.
 * 3. There must not be bounds checking on the array index variable.
 ****************************************/
void arrayVulnerability(int * arr, bool isTrue, int index) {
  for (int i = 0; i < index; i++) {
    cout << arr[i];
  }
  cout << "\n";
}

/**************************************
 * ARRAY WORKING
 * Call arrayVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void arrayWorking() {
  bool isTrue = true;
  int arr[4] = {
    0,
    1,
    2,
    3
  };
  int index = 4;
  cout << "Display array working:\n";
  arrayVulnerability(arr, isTrue, index);

}

/**************************************
 * ARRAY EXPLOIT
 * 1. The attacker provides an array index value outside the expected range
 * 2. The attacker must be able to provide input or redirect
 *    existing input into the array at the index he provided
 * 3. The injected value must alter program state in a way
 *    that is desirable to the attacker
 *************************************/
void arrayExploit() {
  bool isTrue = true;
  int index = 5;
  int arr[4] = {
    0,
    1,
    2,
    3
  };
  cout << "Display array exploit:\n";
  arrayVulnerability(arr, isTrue, index);
}

/*************************************
 * ARC VULNERABILITIES
 * --ADD CONDITIONS
 ****************************************/
void arcVulnerability( /* feel free to add parameters */ ) {}

/**************************************
 * ARC WORKING
 * Call arcWorking() in a way that does
 * not yield unexpected behavior
 *************************************/
void arcWorking() {
  arcVulnerability( /* parameters with non-malicious data */ );
}

/**************************************
 * ARC EXPLOIT
 * --ADD INFO
 *************************************/
void arcExploit() {
  arcVulnerability( /* parameters with malicious data */ );
}

/*************************************
 * VTABLE VULNERABILITIES
 * --ADD CONDITIONS
 ****************************************/
void vTableVulnerability( /* feel free to add parameters */ ) {}

/*******************************************
 * Write a class called Vulnerability that is vulnerable 
 * vulnerable to vtable smashing attack.
 * This means that there must be a method or two in this 
 ********************************************/
class Vulnerability {

  public:
    long buffer[1];

  public:
    virtual void set(int indexBuffer, long valueBuffer);

};

/*******************************************
 * Sets the valueBuffer at an indexBuffer in the buffer. 
 ********************************************/
void Vulnerability::set(int indexBuffer, long valueBuffer) {
  buffer[indexBuffer] = valueBuffer;
  std::cout << "Setting " << valueBuffer << " in index " << indexBuffer << std::endl;
}

/*******************************************
 * Write a function called vtableWorking() 
 * that instantiates a Vulnerability object 
 * and calls the vulnerable method. However, 
 * the method * will behave normally because
 * malicious input is not passed to the method. 
 * Provide output from this function.
 ********************************************/
void vtableWorking() {
  Vulnerability v;
  v.set(1, 0);
  std::cout << "Buffer changed successfully" << std::endl;
}
/*******************************************
 * Write a function called vtableExploit() 
 * that demonstrates vtable spraying. In other words, 
 * it is not necessary to demonstrate vtable smashing, 
 * but rather just spraying. Provide output from this function.
 ********************************************/
void vtableExploit() {
  std::cout << "Executing exploit. We have a vtable smashing attack" << std::endl;
  Vulnerability v;
  v.set(726318, 4);

}

/************************************************************
 * stackVulnerability() that contains a stack 
 * smashing vulnerability. Note that the code 
 * should be something that might actually exist 
 * in the codebase. it provide a useful
 * function if not exploited. 
 * This function contains a stack smashing vulnerability
 ****************************************************************/
void stackVulnerability(long int input[], long int extent) {
  long int buffer[1];

  for (long int i = 0; i < extent; i++) {
    buffer[i] = input[i];
    cout << i << "" << buffer[i] << endl;
    cout << "==> " << endl;
  }

  cout << buffer << endl;
}

/*************************************
 * StackWorking() calls stackVulnerability() 
 * with  non-malicious input. Provide output 
 * from this function.
 ************************************/
void stackWorking() {

  long int buffer[5] = {
    5
  }; //A buffer of 5, a small size

  //StackWorking works here without any problems.
  stackVulnerability(buffer, 1);
  cout << "We see that the buffer was not overwritten, as usual." << endl;
}

/**************************************
 * This function stackExploit() calls the 
 * stackVulnerability() and exploits 
 * overload the buffer. In other words, 
 * we will not be accepting user input here. 
 * Instead we will pass a value or a buffer 
 * to vulnerability() that will cause the 
 * vulnerability to be made manifest.
 *************************************/
void stackExploit() {
  // A string is used to overwrite the buffer with more than it is designed to accept.
  string myPhrase("It's going to be bad!");
  long int buffer[8] = {
    1,
    2,
    3,
    4,
    5,
    (long int) & myPhrase
  };

  stackVulnerability(buffer, 8);
  cout << "Here we have problems and the buffer has been overloaded.";

}

/*************************************
 * HEAP VULNERABILITIES
 * --ADD CONDITIONS
 ****************************************/
void heapVulnerability( /* feel free to add parameters */ ) {}

/**************************************
 * HEAP WORKING
 * Call stackWorking() in a way that does
 * not yield unexpected behavior
 *************************************/
void heapWorking() {
  heapVulnerability( /* parameters with non- malicious data */ );
}

/**************************************
 * HEAP EXPLOIT
 * --ADD INFO
 *************************************/
void heapExploit() {
  heapVulnerability( /* parameters with malicious data */ );
}

/*************************************
 * INT VULNERABILITIES
 * 1. There must be a security check represented by an expression.
 * 2. The expression must have the potential for overflow.
 * 3. At least one of the numbers used to compute the sentinel must be
 * reachable through external input. This sentinel is a variable used to make
 * the security decision from the first requirement.
 ****************************************/
void intVulnerability(int useroffset, int userbuffer) {
  int buffer[256];
  int * sentinel = buffer + 256; // the end of the buffer
  int offset = useroffset; // 0 <= offset <= 255
  if (offset + buffer < sentinel) // code vulnerable to integer overflow
    buffer[offset] = userbuffer; // exploit!
}

/**************************************
 * INT WORKING
 * Call intVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void intWorking() {
  int offset = 7;
  int buffer = 25;
  intVulnerability(offset, buffer);
}

/**************************************
 * INT EXPLOIT
 * 1. Provide input, either a buffer size or a single value, that is directly or
 * indirectly used in the vulnerable expression.
 * 2. The input must exceed the valid bounds of the data-type, resulting in an
 * overflow or underflow condition.
 *************************************/
void intExploit() {
  int offset = 5000;
  int buffer = 7000;
  intVulnerability(offset, buffer);
}

/*************************************
 * ANSI VULNERABILITIES
 * 1. There must be a buffer where the basetype is greater than one.
 * 2. Validation of the buffer must check the size of the buffer rather than the
 * number of elements in the buffer.
 ****************************************/
void ansiVulnerability(int userinput[]) {
  int array[100];
  for (int i = 0; i < sizeof(array); i++)
    array[i] = userinput[i];
}

/**************************************
 * ANSI WORKING
 * Call ansiVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void ansiWorking() {
  int data[100];
  for (int i = 0; i < sizeof(data); i++)
    data[i] = i;
  ansiVulnerability(data);
}

/**************************************
 * ANSI EXPLOIT
 * 1. The attacker must provide more than half as much data into the
 * outwardly facing buffer as it is designed to hold.
 * 2. From here, a variety of injection attacks are possible. The most likely
 * candidates are stack smashing or heap smashing.
 *************************************/
void ansiExploit() {
  int data[100];
  for (int i = 0; i < 55; i++)
    data[i] = i;
  ansiVulnerability(data);
}

int main(int argc,
  const char * argv[]) {

  std::cout << "Please select which vulnerability you would like to observe?" << std::endl;
  std::cout << "[1] To VTable Spraying" << std::endl;
  std::cout << "[2] To Array Index" << std::endl;
  std::cout << "[3] To Integer Overflow" << std::endl;
  std::cout << "[4] To ANSI-Unicode Conversion" << std::endl;
  std::cout << "[5] To Stack Smashing" << std::endl;

  std::string input;
  int numberVulnerability;

  while (true) {
    std::cout << "Choice: ";
    getline(std::cin, input);

    if (input.length() == 1) {
      numberVulnerability = input[0] - '0';

      switch (numberVulnerability) {
      case (1):
        vtableWorking();
        vtableExploit();
        break;
      case (2):
        arrayWorking();
        arrayExploit();
        break;
      case (3): //Integer Overflow
        intWorking();
        intExploit();
        break;
      case (4): // ANSI-Unicode Conversion
        ansiWorking();
        ansiExploit();
        break;
      case (5): // Stack Smashing
        stackWorking();
        stackExploit();
        break;

        //Please add the other vulnerabilities in the program menu
      default:
        std::cout << "Invalid choice, choose again" << std::endl;
        continue;
      }

      break;
    }

    std::cout << "Invalid choice, choose again" << std::endl;
  }

  return 0;
}
