#include <iostream>
using namespace std;

/*************************************
 * ARRAY VULNERABILTY
 * 1. There must be an array and an array index variable
 * 2. The array index variable must be reachable through external input.
 * 3. There must not be bounds checking on the array index variable.
 ****************************************/
void arrayVulnerability(int * arr, bool isTrue, int index)
{
   for (int i = 0; i < index; i++)
   {
	  cout << arr[i];
   }
   cout << "\n";
}

/**************************************
 * ARRAY WORKING
 * Call arrayVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void arrayWorking()
{
   bool isTrue = true;
   int arr[4] = { 0, 1, 2, 3};
   int index = 4;
   cout << "Display array working:\n";
   arrayVulnerability(arr, isTrue, index);
   
}

/**************************************
 * ARRAY EXPLOIT
 * 1. The attacker provides an array index value outside the expected range
 * 2. The attacker must be able to provide input or redirect
 *    existing input into the array at the index he provided
 * 3. The injected value must alter program state in a way
 *    that is desirable to the attacker
 *************************************/
void arrayExploit()
{
   bool isTrue = true;
   int index = 5;
   int arr[4] = { 0, 1, 2, 3};
   cout << "Display array exploit:\n";
   arrayVulnerability(arr, isTrue, index);
}

/*************************************
 * ARC VULNERABILITIES
 * --ADD CONDITIONS
 ****************************************/
void arcVulnerability(/* feel free to add parameters */)
{
}

/**************************************
 * ARC WORKING
 * Call arcWorking() in a way that does
 * not yield unexpected behavior
 *************************************/
void arcWorking()
{
   arcVulnerability(/* parameters with non-malicious data */);
}

/**************************************
 * ARC EXPLOIT
 * --ADD INFO
 *************************************/
void arcExploit()
{
   arcVulnerability(/* parameters with malicious data */);
}

/*************************************
 * VTABLE VULNERABILITIES
 * --ADD CONDITIONS
 ****************************************/
void vTableVulnerability(/* feel free to add parameters */)
{
}

/**************************************
 * VTABLE WORKING
 * Call vTableWorking() in a way that does
 * not yield unexpected behavior
 *************************************/
void vTableWorking()
{
   vTableVulnerability(/* parameters with non-malicious data */);
}

/**************************************
 * VTABLE EXPLOIT
 * --ADD INFO
 *************************************/
void vTableExploit()
{
   vTableVulnerability(/* parameters with malicious data */);
}

/*************************************
 * STACK VULNERABILITIES
 * --ADD CONDITIONS
 ****************************************/
void stackVulnerability(/* feel free to add parameters */)
{
}

/**************************************
 * STACK WORKING
 * Call stackWorking() in a way that does
 * not yield unexpected behavior
 *************************************/
void stackWorking()
{
   stackVulnerability(/* parameters with non- malicious data */);
}

/**************************************
 * STACK EXPLOIT
 * --ADD INFO
 *************************************/
void stackExploit()
{
   stackVulnerability(/* parameters with malicious data */);
}

/*************************************
 * HEAP VULNERABILITIES
 * --ADD CONDITIONS
 ****************************************/
void heapVulnerability(/* feel free to add parameters */)
{
}

/**************************************
 * HEAP WORKING
 * Call stackWorking() in a way that does
 * not yield unexpected behavior
 *************************************/
void heapWorking()
{
   heapVulnerability(/* parameters with non- malicious data */);
}

/**************************************
 * HEAP EXPLOIT
 * --ADD INFO
 *************************************/
void heapExploit()
{
   heapVulnerability(/* parameters with malicious data */);
}

/*************************************
 * INT VULNERABILITIES
 * 1. There must be a security check represented by an expression.
 * 2. The expression must have the potential for overflow.
 * 3. At least one of the numbers used to compute the sentinel must be
 * reachable through external input. This sentinel is a variable used to make
 * the security decision from the first requirement.
 ****************************************/
void intVulnerability(int useroffset, int userbuffer)
{
   int buffer[256];
   int * sentinel = buffer + 256; // the end of the buffer
   int offset = useroffset; // 0 <= offset <= 255
   if (offset + buffer < sentinel) // code vulnerable to integer overflow
   buffer[offset] = userbuffer; // exploit!
}

/**************************************
 * INT WORKING
 * Call intVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void intWorking()
{
   int offset = 7;
   int buffer = 25;
   intVulnerability(offset, buffer);
}

/**************************************
 * INT EXPLOIT
 * 1. Provide input, either a buffer size or a single value, that is directly or
 * indirectly used in the vulnerable expression.
 * 2. The input must exceed the valid bounds of the data-type, resulting in an
 * overflow or underflow condition.
 *************************************/
void intExploit()
{
   int offset = 5000;
   int buffer = 7000;
   intVulnerability(offset, buffer);
}

/*************************************
 * ANSI VULNERABILITIES
 * 1. There must be a buffer where the basetype is greater than one.
 * 2. Validation of the buffer must check the size of the buffer rather than the
 * number of elements in the buffer.
 ****************************************/
void ansiVulnerability(int userinput[])
{
   int array[100];
   for (int i = 0; i < sizeof(array); i++)
   array[i] = userinput[i];
}

/**************************************
 * ANSI WORKING
 * Call ansiVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void ansiWorking()
{
   int data[100];
   for (int i = 0; i < sizeof(data); i++)
   data[i] = i;
   ansiVulnerability(data);
}

/**************************************
 * ANSI EXPLOIT
 * 1. The attacker must provide more than half as much data into the
 * outwardly facing buffer as it is designed to hold.
 * 2. From here, a variety of injection attacks are possible. The most likely
 * candidates are stack smashing or heap smashing.
 *************************************/
void ansiExploit()
{
   int data[100];
   for (int i = 0; i < 55; i++)
   data[i] = i;
   ansiVulnerability(data);
}


int main(int argc, const char * argv[])
{
   //Selene
   arrayWorking();
   arrayExploit();
   //arcWorking();
   //arcExploit();
   
   //Leandro
   //vTableWorking();
   //vTableExploit();
   //stackWorking();
   //stackExploit();
   
   //Landon
   //heapWorking();
   //heapExploit();
   
   //Jaren
   intWorking();
   intExploit();
   ansiWorking();
   ansiExploit();
   
   return 0;
}
