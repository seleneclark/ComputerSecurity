#include <iostream>
#include <string>
#include <string.h>
#include <stdio.h>
using namespace std;

//Selene
void arrayWorking();
void arrayExploit();
//arcWorking();
//arcExploit();

//Leandro
// To VTable Spraying
void vTableExploit();
void vTableWorking();
//  To Stack Smashing
void stackWorking();
void stackExploit();
void stackVulnerability();

//Landon
//heapWorking();
//heapExploit();

//Jaren
void intWorking();
void intExploit();
void ansiWorking();
void ansiExploit();

/*************************************
 * STRUCT  FOR ARRAY VULNERABILTY
 * This is a struct to use in the array vulnerability
 ****************************************/
struct userAccess
{
   char username[9] = "";
   char password[9] = "";
   bool isAdmin = false;
};
/*************************************
 * ARRAY VULNERABILTY
 * 1. There must be an array and an array index variable
 * 2. The array index variable must be reachable through external input.
 * 3. There must not be bounds checking on the array index variable.
 ****************************************/
void arrayVulnerability(string password, string username, int length)
{
   userAccess user;
   user.isAdmin = false;

   for (int i = 0; i < length; i++)
   {
	  user.password[i] = password[i];
	  user.username[i] = username[i];
   }
   cout << "Username: " << user.username << "\n";
   cout << "Password: " << user.password << "\n";
   cout << "Are they an admin? (should be 0): " << user.isAdmin << "\n";
}

/**************************************
 * ARRAY WORKING
 * Call arrayVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void arrayWorking()
{
   string username = "RealUser";
   string password = "secure";
   int length = 9;
   cout << "\nThe Array Index working correctly\n";
   arrayVulnerability(password, username, length);
   cout << "The user is correctly designated as not an admin.\n";
}

/**************************************
 * ARRAY EXPLOIT
 * 1. The attacker provides an array index value outside the expected range
 * 2. The attacker must be able to provide input or redirect
 *    existing input into the array at the index he provided
 * 3. The injected value must alter program state in a way
 *    that is desirable to the attacker
 *************************************/
void arrayExploit()
{
   string username = "RealUser";
   string password = "securepa11";
   int length = 10;
   cout << "\nThe Array Index working incorrectly\n";
   arrayVulnerability(password, username, length);
   cout  << "The user has been incorrectly designated as an admin through the "
		 << "Array Index Vulnerability.\n";
}

/*************************************
 * METHODS  FOR ARC INJECTION VULNERABILTY
 * This is a struct to use in the arc injection vulnerability
 ****************************************/
void selfDistruct() { cout << "Self Distruct Activated!\n"; }
void runningProperly() { cout << "Program running properly\n"; }
typedef void (*functionType)();
struct arcInjection
{
   long data[1];
   functionType pointerFunction;
};

/*************************************
 * ARC VULNERABILITIES
 * 1. There must be a function pointer used in the code.
 * 2. Through some vulnerability, there must be a way for user input to overwrite the function pointer. This
 *   typically happens through a stack buffer vulnerability.
 * 3. After the memory is overwritten, the function pointer must be dereferenced.
 ****************************************/
void arcVulnerability(long *inputArr, int size)
{
   arcInjection arc;
   arc.pointerFunction = runningProperly;
   for (int i = 0; i < size; i ++)
   {
		 arc.data[i] = inputArr[i];
   }
   arc.pointerFunction();
}

/**************************************
 * ARC WORKING
 * Call arcWorking() in a way that does
 * not yield unexpected behavior
 *************************************/
void arcWorking()
{
   cout << "\nThe Arc Injection working correctly:\n";
   int size = 1;
   long inputArr[size+1];
   inputArr[0] = 1;
   inputArr[1] = 1;
   arcVulnerability(inputArr, size);
}

/**************************************
 * ARC EXPLOIT
 * 1. The attacker must exploit a vulnerability allowing unintended access to the function pointer.
 * 2. The attacker must have the address to another function which is to be used to replace the existing
 *   function pointer.
 *************************************/
void arcExploit()
{
   cout << "\nThe Arc Injection working incorrectly:\n";
   functionType address = selfDistruct;
   int size = 2;
   long long addressData = (long long)*address;
   long inputArr[size];
   inputArr[0] = 1;
   inputArr[1] = addressData;
   arcVulnerability(inputArr, size);
   cout << "\n The user has been able to exploit the vulnerability and redirect "
   << "the function pointer to a malicious function\n";
}

/*************************************
 * VTABLE VULNERABILITIES
 * --ADD CONDITIONS
 ****************************************/
void vTableVulnerability( /* feel free to add parameters */ ) {}

/*******************************************
 * Write a class called Vulnerability that is vulnerable 
 * vulnerable to vtable smashing attack.
 * This means that there must be a method or two in this 
 ********************************************/
class Vulnerability {

  public:
    long buffer[1];

  public:
    virtual void set(int indexBuffer, long valueBuffer);

};

/*******************************************
 * Sets the valueBuffer at an indexBuffer in the buffer. 
 ********************************************/
void Vulnerability::set(int indexBuffer, long valueBuffer) {
  buffer[indexBuffer] = valueBuffer;
  std::cout << "Setting " << valueBuffer << " in index " << indexBuffer << std::endl;
}

/*******************************************
 * Write a function called vtableWorking() 
 * that instantiates a Vulnerability object 
 * and calls the vulnerable method. However, 
 * the method * will behave normally because
 * malicious input is not passed to the method. 
 * Provide output from this function.
 ********************************************/
void vtableWorking() {
  Vulnerability v;
  v.set(1, 0);
  std::cout << "Buffer changed successfully" << std::endl;
}
/*******************************************
 * Write a function called vtableExploit() 
 * that demonstrates vtable spraying. In other words, 
 * it is not necessary to demonstrate vtable smashing, 
 * but rather just spraying. Provide output from this function.
 ********************************************/
void vtableExploit() {
  std::cout << "Executing exploit. We have a vtable smashing attack" << std::endl;
  Vulnerability v;
  v.set(726318, 4);

}

/************************************************************
 * stackVulnerability() that contains a stack 
 * smashing vulnerability. Note that the code 
 * should be something that might actually exist 
 * in the codebase. it provide a useful
 * function if not exploited. 
 * This function contains a stack smashing vulnerability
 ****************************************************************/
void stackVulnerability(long int input[], long int extent) {
  long int buffer[1];

  for (long int i = 0; i < extent; i++) {
    buffer[i] = input[i];
    cout << i << "" << buffer[i] << endl;
    cout << "==> " << endl;
  }

  cout << buffer << endl;
}

/*************************************
 * StackWorking() calls stackVulnerability() 
 * with  non-malicious input. Provide output 
 * from this function.
 ************************************/
void stackWorking() {

  long int buffer[5] = {
    5
  }; //A buffer of 5, a small size

  //StackWorking works here without any problems.
  stackVulnerability(buffer, 1);
  cout << "We see that the buffer was not overwritten, as usual." << endl;
}

/**************************************
 * This function stackExploit() calls the 
 * stackVulnerability() and exploits 
 * overload the buffer. In other words, 
 * we will not be accepting user input here. 
 * Instead we will pass a value or a buffer 
 * to vulnerability() that will cause the 
 * vulnerability to be made manifest.
 *************************************/
void stackExploit() {
  // A string is used to overwrite the buffer with more than it is designed to accept.
  string myPhrase("It's going to be bad!");
  long int buffer[8] = {
    1,
    2,
    3,
    4,
    5,
    (long int) & myPhrase
  };

  stackVulnerability(buffer, 8);
  cout << "Here we have problems and the buffer has been overloaded.";

}

/*************************************
 * HEAP VULNERABILITIES
 * --ADD CONDITIONS
 ****************************************/
void heapVulnerability( /* feel free to add parameters */ ) {}

/**************************************
 * HEAP WORKING
 * Call stackWorking() in a way that does
 * not yield unexpected behavior
 *************************************/
void heapWorking() {
  heapVulnerability( /* parameters with non- malicious data */ );
}

/**************************************
 * HEAP EXPLOIT
 * --ADD INFO
 *************************************/
void heapExploit() {
  heapVulnerability( /* parameters with malicious data */ );
}

/*************************************
 * INT VULNERABILITIES
 * 1. There must be a security check represented by an expression.
 * 2. The expression must have the potential for overflow.
 * 3. At least one of the numbers used to compute the sentinel must be
 * reachable through external input. This sentinel is a variable used to make
 * the security decision from the first requirement.
 ****************************************/
void intVulnerability(int useroffset, int userbuffer) {
  int buffer[256];
  int * sentinel = buffer + 256; // the end of the buffer
  int offset = useroffset; // 0 <= offset <= 255
  if (offset + buffer < sentinel) // code vulnerable to integer overflow
    buffer[offset] = userbuffer; // exploit!
}

/**************************************
 * INT WORKING
 * Call intVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void intWorking() {
  int offset = 7;
  int buffer = 25;
  intVulnerability(offset, buffer);
  cout << "Offset: " << offset << " (should be > 1 and <= 255)";
  cout << "Buffer: " << buffer << " (should be < 256 - offset)";
  cout << "Here we have used expected input and the function is working as planned.";
}

/**************************************
 * INT EXPLOIT
 * 1. Provide input, either a buffer size or a single value, that is directly or
 * indirectly used in the vulnerable expression.
 * 2. The input must exceed the valid bounds of the data-type, resulting in an
 * overflow or underflow condition.
 *************************************/
void intExploit() {
  int offset = 5000;
  int buffer = 7000;
  intVulnerability(offset, buffer);
  cout << "Offset: " << offset << " (should be > 1 and <= 255)";
  cout << "Buffer: " << buffer << " (should be < 256 - offset)";
  cout << "Here we have used unexpected input and broken through the"
  << " security check, allowing us to overflow or underflow the data.";
}

/*************************************
 * ANSI VULNERABILITIES
 * 1. There must be a buffer where the basetype is greater than one.
 * 2. Validation of the buffer must check the size of the buffer rather than the
 * number of elements in the buffer.
 ****************************************/
void ansiVulnerability(int userinput[]) {
  int array[100];
  for (int i = 0; i < sizeof(array); i++)
    array[i] = userinput[i];
}

/**************************************
 * ANSI WORKING
 * Call ansiVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void ansiWorking() {
  int data[100];
  for (int i = 0; i < sizeof(data); i++)
    data[i] = i;
  ansiVulnerability(data);
  cout << "Here we have provided an array of 100 data points which "
  << "fits the intended size.  The function is working correctly."
}

/**************************************
 * ANSI EXPLOIT
 * 1. The attacker must provide more than half as much data into the
 * outwardly facing buffer as it is designed to hold.
 * 2. From here, a variety of injection attacks are possible. The most likely
 * candidates are stack smashing or heap smashing.
 *************************************/
void ansiExploit() {
  int data[100];
  for (int i = 0; i < 55; i++)
    data[i] = i;
  ansiVulnerability(data);
  cout << "Here we have provided an array with only 55 data points.  "
  << "Since the buffer checks the size rather than the number of elements, "
  << "we now have room to mount an attack through the remaining section of the array."
}

int main(int argc,
  const char * argv[]) {

  std::cout << "Please select which vulnerability you would like to observe?" << std::endl;
  std::cout << "[1] To VTable Spraying" << std::endl;
  std::cout << "[2] To Array Index" << std::endl;
  std::cout << "[3] To Integer Overflow" << std::endl;
  std::cout << "[4] To ANSI-Unicode Conversion" << std::endl;
  std::cout << "[5] To Stack Smashing" << std::endl;

  std::string input;
  int numberVulnerability;

  while (true) {
    std::cout << "Choice: ";
    getline(std::cin, input);

    if (input.length() == 1) {
      numberVulnerability = input[0] - '0';

      switch (numberVulnerability) {
      case (1):
        vtableWorking();
        vtableExploit();
        break;
      case (2):
        arrayWorking();
        arrayExploit();
        break;
      case (3): //Integer Overflow
        intWorking();
        intExploit();
        break;
      case (4): // ANSI-Unicode Conversion
        ansiWorking();
        ansiExploit();
        break;
      case (5): // Stack Smashing
        stackWorking();
        stackExploit();
        break;

        //Please add the other vulnerabilities in the program menu
      default:
        std::cout << "Invalid choice, choose again" << std::endl;
        continue;
      }

      break;
    }

    std::cout << "Invalid choice, choose again" << std::endl;
  }

  return 0;
}
