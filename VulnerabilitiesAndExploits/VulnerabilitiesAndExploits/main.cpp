#include <iostream>
#include <string>
#include <string.h>
#include <stdio.h>
using namespace std;

/*************************************
 * STRUCT  FOR ARRAY VULNERABILTY
 * This is a struct to use in the array vulnerability
 ****************************************/
struct userAccess
{
   char username[9] = "";
   char password[9] = "";
   bool isAdmin = false;
};
/*************************************
 * ARRAY VULNERABILTY
 * 1. There must be an array and an array index variable
 * 2. The array index variable must be reachable through external input.
 * 3. There must not be bounds checking on the array index variable.
 ****************************************/
void arrayVulnerability(string password, string username, int length)
{
   userAccess user;
   user.isAdmin = false;

   for (int i = 0; i < length; i++)
   {
	  user.password[i] = password[i];
	  user.username[i] = username[i];
   }
   cout << "Username: " << user.username << "\n";
   cout << "Password: " << user.password << "\n";
   cout << "Are they an admin? (should be 0): " << user.isAdmin << "\n";
}

/**************************************
 * ARRAY WORKING
 * Call arrayVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void arrayWorking()
{
   string username = "RealUser";
   string password = "secure";
   int length = 9;
   cout << "\nThe Array Index working correctly\n";
   arrayVulnerability(password, username, length);
   cout << "The user is correctly designated as not an admin.\n";
}

/**************************************
 * ARRAY EXPLOIT
 * 1. The attacker provides an array index value outside the expected range
 * 2. The attacker must be able to provide input or redirect
 *    existing input into the array at the index he provided
 * 3. The injected value must alter program state in a way
 *    that is desirable to the attacker
 *************************************/
void arrayExploit()
{
   string username = "RealUser";
   string password = "securepa11";
   int length = 10;
   cout << "\nThe Array Index working incorrectly\n";
   arrayVulnerability(password, username, length);
   cout  << "The user has been incorrectly designated as an admin through the "
		 << "Array Index Vulnerability.\n";
}

/*************************************
 * METHODS  FOR ARC INJECTION VULNERABILTY
 * This is a struct to use in the arc injection vulnerability
 ****************************************/
void selfDistruct() { cout << "Self Distruct Activated!\n"; }
void runningProperly() { cout << "Program running properly\n"; }
typedef void (*functionType)();
struct arcInjection
{
   long data[1];
   functionType pointerFunction;
};

/*************************************
 * ARC VULNERABILITIES
 * 1. There must be a function pointer used in the code.
 * 2. Through some vulnerability, there must be a way for user input to overwrite the function pointer. This
 *   typically happens through a stack buffer vulnerability.
 * 3. After the memory is overwritten, the function pointer must be dereferenced.
 ****************************************/
void arcVulnerability(long *inputArr, int size)
{
   arcInjection arc;
   arc.pointerFunction = runningProperly;
   for (int i = 0; i < size; i ++)
   {
		 arc.data[i] = inputArr[i];
   }
   arc.pointerFunction();
}

/**************************************
 * ARC WORKING
 * Call arcWorking() in a way that does
 * not yield unexpected behavior
 *************************************/
void arcWorking()
{
   cout << "\nThe Arc Injection working correctly:\n";
   int size = 1;
   long inputArr[size+1];
   inputArr[0] = 1;
   inputArr[1] = 1;
   arcVulnerability(inputArr, size);
}

/**************************************
 * ARC EXPLOIT
 * 1. The attacker must exploit a vulnerability allowing unintended access to the function pointer.
 * 2. The attacker must have the address to another function which is to be used to replace the existing
 *   function pointer.
 *************************************/
void arcExploit()
{
   cout << "\nThe Arc Injection working incorrectly:\n";
   functionType address = selfDistruct;
   int size = 2;
   long long addressData = (long long)*address;
   long inputArr[size];
   inputArr[0] = 1;
   inputArr[1] = addressData;
   arcVulnerability(inputArr, size);
   cout << "\n The user has been able to exploit the vulnerability and redirect "
   << "the function pointer to a malicious function\n";
}

/*************************************
 * VTABLE VULNERABILITIES
 * --ADD CONDITIONS
 ****************************************/
void vTableVulnerability(/* feel free to add parameters */)
{
}

/**************************************
 * VTABLE WORKING
 * Call vTableWorking() in a way that does
 * not yield unexpected behavior
 *************************************/
void vTableWorking()
{
   vTableVulnerability(/* parameters with non-malicious data */);
}

/**************************************
 * VTABLE EXPLOIT
 * --ADD INFO
 *************************************/
void vTableExploit()
{
   vTableVulnerability(/* parameters with malicious data */);
}

/*************************************
 * STACK VULNERABILITIES
 * --ADD CONDITIONS
 ****************************************/
void stackVulnerability(/* feel free to add parameters */)
{
}

/**************************************
 * STACK WORKING
 * Call stackWorking() in a way that does
 * not yield unexpected behavior
 *************************************/
void stackWorking()
{
   stackVulnerability(/* parameters with non- malicious data */);
}

/**************************************
 * STACK EXPLOIT
 * --ADD INFO
 *************************************/
void stackExploit()
{
   stackVulnerability(/* parameters with malicious data */);
}

/*************************************
 * HEAP VULNERABILITIES
 * --ADD CONDITIONS
 ****************************************/
void heapVulnerability(/* feel free to add parameters */)
{
}

/**************************************
 * HEAP WORKING
 * Call stackWorking() in a way that does
 * not yield unexpected behavior
 *************************************/
void heapWorking()
{
   heapVulnerability(/* parameters with non- malicious data */);
}

/**************************************
 * HEAP EXPLOIT
 * --ADD INFO
 *************************************/
void heapExploit()
{
   heapVulnerability(/* parameters with malicious data */);
}

/*************************************
 * INT VULNERABILITIES
 * --ADD CONDITIONS
 ****************************************/
void intVulnerability(/* feel free to add parameters */)
{
}

/**************************************
 * INT WORKING
 * Call intWorking() in a way that does
 * not yield unexpected behavior
 *************************************/
void intWorking()
{
   intVulnerability(/* parameters with non- malicious data */);
}

/**************************************
 * INT EXPLOIT
 * --ADD INFO
 *************************************/
void intExploit()
{
   intVulnerability(/* parameters with malicious data */);
}

/*************************************
 * ANSI VULNERABILITIES
 * --ADD CONDITIONS
 ****************************************/
void ansiVulnerability(/* feel free to add parameters */)
{
}

/**************************************
 * ANSI WORKING
 * Call ansiWorking() in a way that does
 * not yield unexpected behavior
 *************************************/
void ansiWorking(/* parameters with non- malicious data */)
{
   ansiVulnerability();
}

/**************************************
 * ANSI EXPLOIT
 * --ADD INFO
 *************************************/
void ansiExploit()
{
   ansiVulnerability(/* parameters with malicious data */);
}


int main(int argc, const char * argv[])
{
   //Selene
   arrayWorking();
   arrayExploit();
   arcWorking();
   arcExploit();
   
   //Leandro
   //vTableWorking();
   //vTableExploit();
   //stackWorking();
   //stackExploit();
   
   //Landon
   //heapWorking();
   //heapExploit();
   
   //Jaron
   //integerWorking();
   //integerExploit();
   //ansiWorking();
   //ansiExploit();
   
   return 0;
}
