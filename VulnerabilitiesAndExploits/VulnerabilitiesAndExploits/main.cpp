#include <iostream>
#include <string>
#include <string.h>
#include <stdio.h>
using namespace std;

/*************************************
 * STRUCT  FOR ARRAY VULNERABILTY
 * This is a struct to use in the array vulnerability
 ****************************************/
struct userAccess{
   char username[9] = "";
   char password[9] = "";
   bool isAdmin = false;
};
/*************************************
 * ARRAY VULNERABILTY
 * 1. There must be an array and an array index variable
 * 2. The array index variable must be reachable through external input.
 * 3. There must not be bounds checking on the array index variable.
 ****************************************/
void arrayVulnerability(string password, string username, int length)
{
   userAccess user;
   user.isAdmin = false;

   for (int i = 0; i < length; i++)
   {
	  user.password[i] = password[i];
	  user.username[i] = username[i];
   }
   cout << "Username: " << user.username << "\n";
   cout << "Password: " << user.password << "\n";
   cout << "Are they an admin? (should be 0): " << user.isAdmin << "\n";
}

/**************************************
 * ARRAY WORKING
 * Call arrayVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void arrayWorking()
{
   string username = "RealUser";
   string password = "secure";
   int length = 9;
   cout << "\nThe Array Index working correctly\n";
   arrayVulnerability(password, username, length);
   cout << "The user is correctly designated as not an admin.\n";
}

/**************************************
 * ARRAY EXPLOIT
 * 1. The attacker provides an array index value outside the expected range
 * 2. The attacker must be able to provide input or redirect
 *    existing input into the array at the index he provided
 * 3. The injected value must alter program state in a way
 *    that is desirable to the attacker
 *************************************/
void arrayExploit()
{
   string username = "RealUser";
   string password = "securepa11";
   int length = 10;
   cout << "\nThe Array Index working incorrectly\n";
   arrayVulnerability(password, username, length);
   cout  << "The user has been incorrectly designated as an admin through the "
		 << "Array Index Vulnerability.\n";
}

/*************************************
 * METHODS  FOR ARC INJECTION VULNERABILTY
 * This is a struct to use in the arc injection vulnerability
 ****************************************/
void selfDistruct() { cout << "Self Distruct Activated!\n"; }
void runningProperly() { cout << "Program running properly\n"; }

typedef void (*functionType)();
/*************************************
 * ARC VULNERABILITIES
 * 1. There must be a function pointer used in the code.
 * 2. Through some vulnerability, there must be a way for user input to overwrite the function pointer. This
 *   typically happens through a stack buffer vulnerability.
 * 3. After the memory is overwritten, the function pointer must be dereferenced.
 ****************************************/
void arcVulnerability(functionType functionAddress)
{
   cout << (long long)*functionAddress << "\n";
   long buffer[1];

   void (*pointerFunction)() = runningProperly;
   cout << "Buffer: " << &buffer << "\n";
   cout << "pointerFunction " << &pointerFunction << "\n";
   cout << "Contents of pointer function " << (long long)*pointerFunction << "\n";
   
   long long temp = (long long)*functionAddress;
   cout << temp << "\n";
   int i = 0;
   buffer[16] = '4';
   buffer[17] = '2';
   buffer[18] = '9';
   buffer[19] = '4';
   buffer[20] = '9';
   buffer[21] = '7';
   buffer[22] = '8';
   buffer[23] = '6';
   buffer[24] = '5';
   buffer[25] = '6';
   cout << "pointerFunction " << &pointerFunction << "\n";
   cout << "Contents of pointer function " << (long long)*pointerFunction << "\n";
//   if (functionAddress != NULL)
//   {
//	  pointerFunction = functionAddress;
//   }
   
   pointerFunction();
}

/**************************************
 * ARC WORKING
 * Call arcWorking() in a way that does
 * not yield unexpected behavior
 *************************************/
void arcWorking()
{
   functionType address = NULL;
   arcVulnerability(address);
}

/**************************************
 * ARC EXPLOIT
 * 1. The attacker must exploit a vulnerability allowing unintended access to the function pointer.
 * 2. The attacker must have the address to another function which is to be used to replace the existing
 *   function pointer.
 *************************************/
void arcExploit()
{
   functionType address = selfDistruct;
   arcVulnerability(address);
}

/*************************************
 * VTABLE VULNERABILITIES
 * --ADD CONDITIONS
 ****************************************/
void vTableVulnerability(/* feel free to add parameters */)
{
}

/**************************************
 * VTABLE WORKING
 * Call vTableWorking() in a way that does
 * not yield unexpected behavior
 *************************************/
void vTableWorking()
{
   vTableVulnerability(/* parameters with non-malicious data */);
}

/**************************************
 * VTABLE EXPLOIT
 * --ADD INFO
 *************************************/
void vTableExploit()
{
   vTableVulnerability(/* parameters with malicious data */);
}

/*************************************
 * STACK VULNERABILITIES
 * --ADD CONDITIONS
 ****************************************/
void stackVulnerability(/* feel free to add parameters */)
{
}

/**************************************
 * STACK WORKING
 * Call stackWorking() in a way that does
 * not yield unexpected behavior
 *************************************/
void stackWorking()
{
   stackVulnerability(/* parameters with non- malicious data */);
}

/**************************************
 * STACK EXPLOIT
 * --ADD INFO
 *************************************/
void stackExploit()
{
   stackVulnerability(/* parameters with malicious data */);
}

/*************************************
 * HEAP VULNERABILITIES
 * --ADD CONDITIONS
 ****************************************/
void heapVulnerability(/* feel free to add parameters */)
{
}

/**************************************
 * HEAP WORKING
 * Call stackWorking() in a way that does
 * not yield unexpected behavior
 *************************************/
void heapWorking()
{
   heapVulnerability(/* parameters with non- malicious data */);
}

/**************************************
 * HEAP EXPLOIT
 * --ADD INFO
 *************************************/
void heapExploit()
{
   heapVulnerability(/* parameters with malicious data */);
}

/*************************************
 * INT VULNERABILITIES
 * --ADD CONDITIONS
 ****************************************/
void intVulnerability(/* feel free to add parameters */)
{
}

/**************************************
 * INT WORKING
 * Call intWorking() in a way that does
 * not yield unexpected behavior
 *************************************/
void intWorking()
{
   intVulnerability(/* parameters with non- malicious data */);
}

/**************************************
 * INT EXPLOIT
 * --ADD INFO
 *************************************/
void intExploit()
{
   intVulnerability(/* parameters with malicious data */);
}

/*************************************
 * ANSI VULNERABILITIES
 * --ADD CONDITIONS
 ****************************************/
void ansiVulnerability(/* feel free to add parameters */)
{
}

/**************************************
 * ANSI WORKING
 * Call ansiWorking() in a way that does
 * not yield unexpected behavior
 *************************************/
void ansiWorking(/* parameters with non- malicious data */)
{
   ansiVulnerability();
}

/**************************************
 * ANSI EXPLOIT
 * --ADD INFO
 *************************************/
void ansiExploit()
{
   ansiVulnerability(/* parameters with malicious data */);
}


int main(int argc, const char * argv[])
{
   //Selene
   arrayWorking();
   arrayExploit();
//   arcWorking();
   arcExploit();
   
   //Leandro
   //vTableWorking();
   //vTableExploit();
   //stackWorking();
   //stackExploit();
   
   //Landon
   //heapWorking();
   //heapExploit();
   
   //Jaron
   //integerWorking();
   //integerExploit();
   //ansiWorking();
   //ansiExploit();
   
   return 0;
}
